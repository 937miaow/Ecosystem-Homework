---
title: 简单生态系统仿真实验
date: 2024-06-21
author: hhh
---

# 简单生态系统仿真实验

[toc]

## 1.摘要

​	本实验报告介绍了本人在了解供参考的仿真模型后，阅读供参考的代码，然后在代码的基础上进行完善或者重构的过程。取得了不错的成果，但模拟结果还是有些问题，推测是规则编写出错。



## 2.关键词

​	重构、内存管理、性能、基类、菜单、添加功能。



## 3. 前言

​	本文采用 $Typora$ 编辑器和 $Markdown$ 语法编写，后转成 $word$ 格式。本人会提供 $doc$ 格式、$pdf$ 格式以及 $md$ 格式的文件供查看。

​	本实验采用的环境为 $VS、VS\ Code\ \&\ mingw\ g++$ 。

​	若您觉得本文后面的代码部分过长，可来到我的 $github$ 仓库直接下载所有文件进行查看。本人的 $github$ 仓库地址为：[937miaow/Ecosystem-Homework (github.com)](https://github.com/937miaow/Ecosystem-Homework)



## 4.软件的开发过程

### 前期准备

- 将代码文件改成 $Unicode$ 编码格式，不然会编译出乱码
- 阅读实验要求，了解重构建议，挑选要实现的建议并将其按先后顺序排序。
   - 即以下标题顺序即为先后顺序



### 优化性能

​	将 `world->sums(pos,sum)` 在更新循环开始时只计算一次，并将结果缓存起来供所有单元使用。

​	首先在 `world.h` 里面新增一个成员变量 `int cachedSums[N][N][STATES];` ，用于缓存周围生物数目统计结果。

​	其次，将 `curMap` 改成用 `vector` 容器来存储，提升性能。

```c++
void World::update() // 有更新
{
	// 先计算周围生物数目统计结果
	for (int i = 1; i < N - 1; i++)
		for (int j = 1; j < N - 1; j++)
		{
			sums(Position{i, j}, cachedSums[i][j]);
		}

	// 更新各单元状态
	for (int i = 1; i < N - 1; i++)
		for (int j = 1; j < N - 1; j++)
		{
			LivingUnit *p = locate(i, j);
			curMap[i][j] = p->nextState();
		}
}
```

```c++
void World::sums(Position pos, int sum[STATES])
{
	sum[EMPTY] = sum[GRASS] = 0;
	sum[RABBIT] = sum[FOX] = 0;

	for (int i = -1; i <= 1; ++i)
		for (int j = -1; j <= 1; ++j)
		{
			if (i == 0 && j == 0)
				continue;
			State state = curMap[pos.row + i][pos.colum + j];
			sum[state]++;
		}
}
```



​	由于将 `curMap` 修改为 `vector` 容器，所以我修改了 `World` 的构造函数，这样可以将 `initWorld` 函数删掉。

```c++
World::World(int index): curMap(N, vector<State>(N, EMPTY)) // 新增 初始化curMap 这样可以删去initWorld函数
{
	switch (index)
	{
	case WORLD_OF_GRASS:
		worldOfGrass();
		break;

	case WORLD_OF_RABBIT:
		worldOfRabbit();
		break;
	case WORLD_OF_FOX:
		worldOfFox();
		break;
	}
}
```





### 提高内存管理

​	前文提到，将 `curMap` 改成用 `vector` 容器来存储，优化了内存管理

​	其次，在 `world.h` 里发现world的析构函数没写，虽然没有影响，但还是补了上去。





### 通用功能移到基类

​	在 `living` 类中新增一个保护方法 `updateSums()` ，然后修改子类的 `round()` 函数，直接调用 `living` 的方法，简化代码。

```c++
//living.h
void updateSums()
	{
		for (int i = 0; i < STATES; ++i)
		{
			sum[i] = world->cachedSums[pos.row][pos.colum][i];
		}
	}

//fox.h e.g
void FoxUnit::round() // 更新 将代码移到living.h基类中
{
	updateSums();
}
```



​	同时，我们加上析构函数。

```c++
//world.cpp
World::~World()
{
	for (int i = 0; i < N; i++)
		for (int j = 0; j < N; j++)
			delete locate(i, j);
}

//scene.cpp
Scene::~Scene()
{
	delete world;
}
```





### 修改显示方式

​	因原程序采用数字的方式显示物种，现改为用字母来显示，方便查看。

```c++
void World::display()
{
	for (int i = 0; i < N; ++i)
	{
		cout << endl;
		for (int j = 0; j < N; ++j)
		{
			switch (curMap[i][j]) // 修改了显示方式
			{
			case EMPTY:
				cout << color(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED) << '0';
				break;
			case GRASS:
				cout << color(FOREGROUND_GREEN) << 'G';
				break;
			case RABBIT:
				cout << color(FOREGROUND_RED | FOREGROUND_GREEN) << 'R';
				break;
			case FOX:
				cout << color(FOREGROUND_RED) << 'F';
				break;
			}
		}
	}
	cout << endl
		 << endl;
}
```



​	同时，这步测试的时候发现，初始化之后没有显示初始化之后的世界，因此在 `worldOfFox()` 函数的最后加上了 `display();` 语句，以输出初始化之后的世界。



### 编写菜单

​	要实现配置数据的外部化，首先要编写一个菜单，来方便用户通过菜单，来访问修改数据的页面。

​	我们首先定义一个全局变量 `int world_choice = WORLD_OF_FOX;` ，来表示默认的世界选择为狐狸的世界。

#### 主菜单

​	主菜单代码如下：

```c++
void show_menu()
{
	cout << "##########################################################################################" << endl;
	cout << "##                               * 欢迎进入生态仿真系统 *                               ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "##                                * 退出系统 *      请按 0                              ##" << endl;
	cout << "##                                * 进入模拟 *      请按 1                              ##" << endl;
	cout << "##                              * 修改配置数据 *    请按 2                              ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "请输入你的选择：";
}
```



​	由此我们可以在 `main` 函数里写出如下 `while` 循环。

```c++
int main()
{
	system("COLOR 0A");
	int choice = -1;

	while (choice != 0)
	{
		system("cls");
		show_menu();
		cin >> choice;
		switch (choice)
		{
		case 1:
			start_simulation_menu();
			break;
		case 2:
			modify_data_menu();
			break;
		default:
			break;
		}
	}
}
```



​	补充完 `main` 函数，我们继续编写 `start_simulation_menu()` 和 `modify_data_menu()` 函数。

#### 进入模拟菜单

​	对于 `start_simulation_menu()` ，首先编写完菜单部分

```c++
void start_simulation_menu()
{
	int sim_choice = -1;

	while (sim_choice != 0)
	{
		system("cls");
		system("COLOR 0A");
		cout << "##########################################################################################" << endl;
		cout << "##                               * 生态仿真系统模拟菜单 *                               ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
		cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
		cout << "##                                * 选择世界 *       请按 2                             ##" << endl;
		cout << "##                                * 开始模拟 *       请按 3                             ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "当前选择的世界是：" << WorldChoiceShow(world_choice) << endl;
		cout << "请输入你的选择：";
		cin >> sim_choice;
		switch (sim_choice)
		{
		case 1:
			system("pause");
			exit(0);
		case 2:
			choose_world(world_choice);
			break;
		case 3:
		{
			World world(world_choice);
			Scene scene(world);
			scene.run();
			system("pause");
			break;
		}
		default:
			break;
		}
	}
}
```



​	然后我们需要一个 `WorldChoiceShow(world_choice)` 函数来返回当前选择的世界类型。

```c++
string WorldChoiceShow(int world_choice)
{
	switch (world_choice)
	{
	case WORLD_OF_RABBIT:
		return "兔子世界";
	case WORLD_OF_FOX:
		return "狐狸世界";
	case WORLD_OF_GRASS:
		return "草世界";
	default:
		return "未知世界";
	}
}
```



​	接着编写 `choose_world(world_choice)` 函数，该函数是选择世界的页面，以便用户自行选择世界类型。

```c++
void choose_world(int &world_choice)
{
	system("cls");
	cout << "##########################################################################################" << endl;
	cout << "##                             * 生态仿真系统选择世界页面 *                             ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
	cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
	cout << "##                                * 兔子世界 *       请按 2                             ##" << endl;
	cout << "##                                * 狐狸世界 *       请按 3                             ##" << endl;
	cout << "##                                 * 草世界 *        请按 4                             ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "当前选择的世界是：" << WorldChoiceShow(world_choice) << endl;
	cout << "请输入你的选择：";

	int world_choice_input;
	cin >> world_choice_input;
	switch (world_choice_input)
	{
	case 0:
		break;
	case 1:
		system("pause");
		exit(0);
	case 2:
		world_choice = WORLD_OF_RABBIT;
		break;
	case 3:
		world_choice = WORLD_OF_FOX;
		break;
	case 4:
		world_choice = WORLD_OF_GRASS;
		break;
	default:
		break;
	}
}
```



​	由此，进入模拟菜单编写完成，接下来是修改配置数据菜单

#### 修改配置数据菜单

​	同样的，我们先照搬格式，编写出修改配置数据菜单。

```
void modify_data_menu()
{
	int modmenu_choice = -1;
	readConfig("config.txt");
	while (modmenu_choice != 0)
	{
		system("cls");
		system("COLOR 0A");
		cout << "##########################################################################################" << endl;
		cout << "##                           * 生态仿真系统修改配置数据菜单 *                           ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
		cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
		cout << "##                                * 修改数据 *       请按 2                             ##" << endl;
		cout << "##########################################################################################" << endl;
		ShowConfig();
		cout << endl;
		cout << "请输入你的选择：";
		cin >> modmenu_choice;
		switch (modmenu_choice)
		{
		case 0:
			break;
		case 1:
			system("pause");
			exit(0);
		case 2:
			modify_data();
			break;
		}
	}
}
```



​	接着再去编写修改数据的页面。

```c++
//basic.h新增
void readConfig(const char *filename);
void modifyConfig(const char *filename, const char *key, int value);
void ShowConfig();
enum Config
{
    Placeholder, // 占位符
    DRAB_KEY,
    DFOX_KEY,
    TMFOX_KEY,
    CYCLES_KEY
};

//main.cpp
void modify_data()
{
	int mod_choice = -1;
	while (mod_choice != 0)
	{
		system("cls");
		cout << "##########################################################################################" << endl;
		cout << "##                           * 生态仿真系统修改配置数据页面 *                           ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                                * 输入0 以返回上一级 *                                ##" << endl;
		cout << "##                              * 输入对应数字以修改配置 *                              ##" << endl;
		cout << "##########################################################################################" << endl;
		ShowConfig();
		cout << endl;
		cout << "请输入你要修改的配置数据的键值：";
		cin >> mod_choice;
		switch (mod_choice)
		{
		case 0:
			break;
		case DRAB_KEY:
		{
			int value;
			cout << "请输入新的兔子寿命：";
			cin >> value;
			modifyConfig("config.txt", "DRAB", value);
			break;
		}
		case DFOX_KEY:
		{
			int value;
			cout << "请输入新的狐狸寿命：";
			cin >> value;
			modifyConfig("config.txt", "DFOX", value);
			break;
		}
		case TMFOX_KEY:
		{
			int value;
			cout << "请输入新的太多的狐狸数：";
			cin >> value;
			modifyConfig("config.txt", "TMFOX", value);
			break;
		}
		case CYCLES_KEY:
		{
			int value;
			cout << "请输入新的仿真总步数：";
			cin >> value;
			modifyConfig("config.txt", "CYCLES", value);
			break;
		}
		default:
			break;
		}
	}
}
```



​	这里会有两个新增的东西，一个是 `enum Config` ，其定义在 `basic.h` 中；另一个则是在外部配置数据的函数。





### 外部化配置数据

​	前面我们已经编写了 `modify_data()` 函数，那么现在我们就来实现配置数据外部化。

​	首先，我们要将 `basic.h` 中的数据由 `const` 改为 `extern` ，即：

```c++
//basic.h
extern int DRAB;   // 兔子的寿命
extern int DFOX;   // 狐狸的寿命
extern int TMFOX;  // 太多的狐狸数
extern int CYCLES; // 仿真总步数
```



​	然后新建一个 `basic.cpp` 文件，来实现新增的三个函数。

​	我们考虑到，如果没有配置文件的话，我们必须要自己创建一个默认配置文件，因此我们先在 `basic.cpp `中定义默认值。

```c++
// 默认值
int DRAB = 3;
int DFOX = 4;
int DLION = 5;
int TMFOX = 2;
int CYCLES = 5;
```



​	然后，我们由于要新建一个默认配置文档，则可以写出以下代码：

```c++
void writeDefaultConfig(const char *filename)
{
    ofstream file(filename);
    if (!file)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }
    file << "DRAB=" << DRAB << endl;
    file << "DFOX=" << DFOX << endl;
    file << "TMFOX=" << TMFOX << endl;
    file << "CYCLES=" << CYCLES;
    file.close();
}
```



​	那么接下来我们就可以编写我们的读文件函数：

```c++
void readConfig(const char *filename)
{
    ifstream file(filename);
    if (!file)
    {
        cerr << "找不到配置文件，现创建一个默认配置文件：" << filename << endl;
        writeDefaultConfig(filename);
        file.open(filename);
        if (!file)
        {
            cerr << "打开文件失败：" << filename << endl;
            return;
        }
    }

    string line;
    while (getline(file, line))
    {
        istringstream iss(line);
        string key;
        int value;
        if (getline(iss, key, '=') && iss >> value)
        {
            if (key == "DRAB")
            {
                DRAB = value;
            }
            else if (key == "DFOX")
            {
                DFOX = value;
            }
            else if (key == "TMFOX")
            {
                TMFOX = value;
            }
            else if (key == "CYCLES")
            {
                CYCLES = value;
            }
        }
    }
    file.close();
}
```



​	编写完读文件函数，那自然剩下的就是写文件函数。由于写文件函数最好就是接受一个特定的 `key` 值，来修改相应的数据，所以我们来把它模块化。

```c++
void modifyConfig(const char *filename, const char *key, int value)
{
    ifstream file(filename);
    if (!file)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }

    stringstream buffer;
    buffer << file.rdbuf();
    string content = buffer.str();
    file.close();

    string line;
    string newContent;
    istringstream iss(content);
    bool keyFound = false;

    while (getline(iss, line))
    {
        if (line.find(key) != string::npos && line.find('=') != string::npos)
        {
            istringstream lineStream(line);
            string currentKey;
            if (getline(lineStream, currentKey, '=') && currentKey == key)
            {
                newContent += key + string("=") + to_string(value) + "\n";
                keyFound = true;
            }
            else
            {
                newContent += line + "\n";
            }
        }
        else
        {
            newContent += line + "\n";
        }
    }

    if (!keyFound)
    {
        newContent += key + string("=") + to_string(value) + "\n";
    }

    ofstream outFile(filename);
    if (!outFile)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }
    outFile << newContent;
    outFile.close();
}
```





### 添加控制功能

​	对于控制功能，修改 `Scene::run()` 函数，添加 `switch` 语句即可。

```c++
void Scene::run()
{
	int run_choice = -1;
	int i = 0;
	while (run_choice != 0 && i < CYCLES)
	{
		cout << "* 0 - 退出模拟 *  * 1 - 退出系统 *  * 2 - 继续模拟 *" << endl;
		cout << "请输入你的选择：";
		cin >> run_choice;
		switch (run_choice)
		{
		case 0:
			return;
		case 1:
			system("pause");
			exit(0);
		case 2:
			update();
			display();
			break;
		default:
			cout << "输入错误，请重新输入" << endl;
		}
		++i;
	}
	cout << "已达到最大步数，本轮模拟结束！！！" << endl
		 << endl;
}
```





### 补充世界函数

​	在完善规则之前，我们要先把 `worldOfFox` 等一系列函数修改或补充。

​	对于 `worldOfFox` 函数，其初始化的逻辑极其不合理。应该改为取随机数，随机在地图上生成狐狸。

```c++
void World::worldOfFox()
{
	// 使用当前时间作为随机数生成器的种子
	srand(time(0));

	// 生成狐狸的位置
	int foxCount = N / 5; // 假设地图大小是 N x N，生成 N/5 只狐狸
	for (int i = 0; i < foxCount; ++i)
	{
		int row = rand() % (N - 4) + 2; // 随机生成的位置范围是 [2, N-3]
		int col = rand() % (N - 4) + 2;

		// 放置狐狸
		curMap[row][col] = FOX;

		// 放置旁边的一只狐狸
		int direction = rand() % 4;
		switch (direction)
		{
		case 0:
			curMap[row - 1][col] = FOX;
			break; // 上
		case 1:
			curMap[row + 1][col] = FOX;
			break; // 下
		case 2:
			curMap[row][col - 1] = FOX;
			break; // 左
		case 3:
			curMap[row][col + 1] = FOX;
			break; // 右
		}

		// 放置周围的兔子
		for (int dr = -1; dr <= 1; ++dr)
		{
			for (int dc = -1; dc <= 1; ++dc)
			{
				if ((dr != 0 || dc != 0) && curMap[row + dr][col + dc] != FOX)
				{
					curMap[row + dr][col + dc] = RABBIT;
				}
			}
		}
	}

	// 填充剩余位置为草
	for (int i = 1; i < N - 1; ++i)
	{
		for (int j = 1; j < N - 1; ++j)
		{
			if (curMap[i][j] == EMPTY)
			{
				curMap[i][j] = GRASS;
			}
		}
	}
	display();
	cout << endl;
}
```



​	那对于另外两个函数，也是如此：

```c++
void World::worldOfGrass()
{
	srand(time(0)); // 使用当前时间作为随机数种子

	// 计算需要生成草的总数，大约占据地图八分之一的位置
	int grass_count = (N * N) / 8;
	int generated_grass = 0;

	while (generated_grass < grass_count)
	{
		int row = rand() % (N - 4) + 2; // 确保不会在最外围生成
		int col = rand() % (N - 4) + 2;

		// 如果当前位置为空，则生成草
		if (curMap[row][col] == EMPTY)
		{
			curMap[row][col] = GRASS;
			++generated_grass;

			// 在周围8格生成草
			for (int i = -1; i <= 1; ++i)
				for (int j = -1; j <= 1; ++j)
					if (!(i == 0 && j == 0)) // 排除自身位置
						if (curMap[row + i][col + j] == EMPTY)
						{
							curMap[row + i][col + j] = GRASS;
							++generated_grass;
						}
		}
	}
	display();
	cout << endl;
}

void World::worldOfRabbit()
{
	srand(time(0)); // 使用当前时间作为随机数种子

	// 随机生成几只兔子
	int rabbit_count = rand() % 3 + 3; // 生成3到5只兔子
	vector<Position> rabbit_positions;

	for (int i = 0; i < rabbit_count; ++i)
	{
		int row = rand() % (N - 4) + 2; // 确保不会在边界生成
		int col = rand() % (N - 4) + 2;

		// 确保不会生成在相同位置
		while (curMap[row][col] == RABBIT)
		{
			row = rand() % (N - 4) + 2;
			col = rand() % (N - 4) + 2;
		}

		curMap[row][col] = RABBIT;
		rabbit_positions.push_back({row, col});

		// 在兔子旁边生成另一只兔子
		int direction = rand() % 4;
		switch (direction)
		{
		case 0:
			row = max(2, row - 1);
			break; // up
		case 1:
			row = min(N - 3, row + 1);
			break; // down
		case 2:
			col = max(2, col - 1);
			break; // left
		case 3:
			col = min(N - 3, col + 1);
			break; // right
		}
		curMap[row][col] = RABBIT;
		rabbit_positions.push_back({row, col});
	}

	// 剩余的位置生成草
	for (int i = 1; i < N - 1; ++i)
	{
		for (int j = 1; j < N - 1; ++j)
		{
			if (curMap[i][j] == EMPTY)
			{
				curMap[i][j] = GRASS;
			}
		}
	}
	display();
	cout << endl;
}
```



​	同时，在修改这三个函数，进行测试的时候，编译器报错。排查后发现 `Scene.cpp` 的析构函数直接 `delete world;` ，然而并不需要 `Scene` 来做这个事情，应该是 `World` 的析构函数来做，所以将 `Scene` 的析构函数删掉。



### 修改完善物种规则

​	下面我就来总述捕食者的规则：

​		1.年龄大于最大年龄时，返回EMPTY（这个没问题）
​		2.狐狸周围大于TMFOX时，返回EMPTY（这个没问题）；但是缺少了兔子，补充一个TMRAB

​		3.缺少繁殖功能：当周围有食物（兔子吃草，狐狸吃兔子）且有一个同物种的生物时，选择一个位置的食物吃掉，并在那个位置生成一个新的动物。

​		4.个人觉得缺少了先后顺序，假如兔子吃草，但是周围有狐狸把它吃掉，那么草应该保留，兔子被吃掉。因此要修改代码，加一个先后顺序。先后顺序应为：`被捕食者吃掉>吃食物>繁殖` 。



### 添加新物种

​	添加了一个狮子物种。



### 代码

#### basic.h

```c++
// basic.h
#ifndef _BASIC_H_
#define _BASIC_H_

// 和程序实现相关的一些基础的常量、函数声明

enum State
{
    EMPTY,
    GRASS,
    RABBIT,
    FOX,
    LION,
    STATES
};

enum Config
{
    Placeholder, // 占位符
    DRAB_KEY,
    DFOX_KEY,
    DLION_KEY,
    TMRAB_KEY,
    TMFOX_KEY,
    TMLION_KEY,
    CYCLES_KEY
};

extern int DRAB;   // 兔子的寿命
extern int DFOX;   // 狐狸的寿命
extern int DLION;  // 狮子的寿命
extern int TMRAB;  // 太多的兔子数
extern int TMFOX;  // 太多的狐狸数
extern int TMLION; // 太多的狮子数
extern int CYCLES; // 仿真总步数
const int N = 40;  // 世界的大小

void readConfig(const char *filename);
void modifyConfig(const char *filename, const char *key, int value);
void ShowConfig();

struct Position // 位置
{
    int row;   // 行
    int colum; // 列
};

#include <iostream>
using namespace std;

// 用于在控制台窗口显示彩色的字体
#include <windows.h>
struct color
{
    color(WORD attribute) : m_color(attribute){};
    WORD m_color; // 颜色值
};

// 使用模板函数
template <class _Elem, class _Traits>
std::basic_ostream<_Elem, _Traits> &
operator<<(std::basic_ostream<_Elem, _Traits> &i, const color &c)
{
    HANDLE hStdout = GetStdHandle(STD_OUTPUT_HANDLE); // 获取标准输出句柄
    SetConsoleTextAttribute(hStdout, c.m_color);      // 设置文本颜色
    return i;
}

#endif
```



#### basic.cpp

```c++
#include "basic.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
using namespace std;

// 默认值
int DRAB = 3;
int DFOX = 4;
int DLION = 8;
int TMRAB = 8;
int TMFOX = 8;
int TMLION = 3;
int CYCLES = 5;

void writeDefaultConfig(const char *filename)
{
    ofstream file(filename);
    if (!file)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }
    file << "DRAB=" << DRAB << endl;
    file << "DFOX=" << DFOX << endl;
    file << "DLION=" << DLION << endl;
    file << "TMRAB=" << TMRAB << endl;
    file << "TMFOX=" << TMFOX << endl;
    file << "TMLION=" << TMLION << endl;
    file << "CYCLES=" << CYCLES << endl;
    file.close();
}

void readConfig(const char *filename)
{
    ifstream file(filename);
    if (!file)
    {
        cerr << "找不到配置文件，现创建一个默认配置文件：" << filename << endl;
        writeDefaultConfig(filename);
        file.open(filename);
        if (!file)
        {
            cerr << "打开文件失败：" << filename << endl;
            return;
        }
    }

    string line;
    while (getline(file, line))
    {
        istringstream iss(line);
        string key;
        int value;
        if (getline(iss, key, '=') && iss >> value)
        {
            if (key == "DRAB")
                DRAB = value;
            else if (key == "DFOX")
                DFOX = value;
            else if (key == "DLION")
                DLION = value;
            else if (key == "TMRAB")
                TMRAB = value;
            else if (key == "TMFOX")
                TMFOX = value;
            else if (key == "TMLION")
                TMLION = value;
            else if (key == "CYCLES")
                CYCLES = value;
        }
    }
    file.close();
}

void modifyConfig(const char *filename, const char *key, int value)
{
    ifstream file(filename);
    if (!file)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }

    stringstream buffer;
    buffer << file.rdbuf();
    string content = buffer.str();
    file.close();

    string line;
    string newContent;
    istringstream iss(content);
    bool keyFound = false;

    while (getline(iss, line))
    {
        if (line.find(key) != string::npos && line.find('=') != string::npos)
        {
            istringstream lineStream(line);
            string currentKey;
            if (getline(lineStream, currentKey, '=') && currentKey == key)
            {
                newContent += key + string("=") + to_string(value) + "\n";
                keyFound = true;
            }
            else
            {
                newContent += line + "\n";
            }
        }
        else
        {
            newContent += line + "\n";
        }
    }

    if (!keyFound)
    {
        newContent += key + string("=") + to_string(value) + "\n";
    }

    ofstream outFile(filename);
    if (!outFile)
    {
        cerr << "打开文件失败：" << filename << endl;
        return;
    }
    outFile << newContent;
    outFile.close();
}

void ShowConfig()
{
    cout << "当前配置如下：" << endl;
    ifstream file("config.txt");
    int i = 1;
    while (file)
    {
        string line;
        getline(file, line);
        if (!line.empty())
        {
            cout << i << " - " << line << endl;
            ++i;
        }
    }
    file.close();
}
```



#### world.h

```c++
// world.h

#ifndef _WORLD_H_
#define _WORLD_H_

#include "basic.h"
#include <vector>
#include <array>
// 与程序内部实现相关的一些变量定义

typedef vector<vector<State>> Map;

class LivingUnit;
class EmptyUnit;
class GrassUnit;
class RabbitUnit;
class FoxUnit;

enum SimWorld
{
	WORLD_OF_GRASS,
	WORLD_OF_RABBIT,
	WORLD_OF_FOX,
	WORLD_OF_LION
}; // 仿真的世界

class World
{
public:
	World(int index);
	void update();							   // 更新世界
	void display();							   // 显示世界
	void sums(Position pos, int sum[STATES]);  // 指定位置周围的各类生物的总数的列表，返回结果保存在数组int sum[STATES]中
	int cachedSums[N][N][STATES];			   // 新增 缓存周围生物数目统计结果
	void setUnitAt(Position pos, State state); // 新增 设置指定位置的生物状态
	State getUnitAt(Position pos);			   // 新增 获取指定位置的生物状态

private:
	void worldOfGrass();					// 配置青草的世界
	void worldOfRabbit();					// 配置兔子的世界
	void worldOfFox();						// 配置狐狸的世界
	void worldOfLion();						// 新增 配置狮子的世界
	void initWorld();						// 初始化世界
	LivingUnit *locate(int row, int colum); // 根据指定位置返回指向存在于该位置的对象的指针
	vector<vector<State>> curMap;			// 当前的世界地图 修改为vector 提升内存管理效率
};

#endif
```



#### world.cpp

```c++
// world.cpp
#include <iostream>
#include <random>
#include <ctime>
#include <cstdlib>
using namespace std;

#include "basic.h"

#include "empty.h"
#include "grass.h"
#include "rabbit.h"
#include "fox.h"
#include "lion.h"

#include "world.h"

World::World(int index) : curMap(N, vector<State>(N, EMPTY))
{
	initWorld();

	switch (index)
	{
	case WORLD_OF_GRASS:
		worldOfGrass();
		break;

	case WORLD_OF_RABBIT:
		worldOfRabbit();
		break;
	case WORLD_OF_FOX:
		worldOfFox();
		break;
	case WORLD_OF_LION:
		worldOfLion();
		break;
	}
}

void World::initWorld()
{
	for (int i = 0; i < N; ++i)
		for (int j = 0; j < N; ++j)
			curMap[i][j] = EMPTY;
}

void World::worldOfGrass()
{
	srand(time(0)); // 使用当前时间作为随机数种子

	// 计算需要生成草的总数，大约占据地图八分之一的位置
	int grass_count = (N * N) / 8;
	int generated_grass = 0;

	while (generated_grass < grass_count)
	{
		int row = rand() % (N - 4) + 2; // 确保不会在最外围生成
		int col = rand() % (N - 4) + 2;

		// 如果当前位置为空，则生成草
		if (curMap[row][col] == EMPTY)
		{
			curMap[row][col] = GRASS;
			++generated_grass;

			// 在周围8格生成草
			for (int i = -1; i <= 1; ++i)
				for (int j = -1; j <= 1; ++j)
					if (!(i == 0 && j == 0)) // 排除自身位置
						if (curMap[row + i][col + j] == EMPTY)
						{
							curMap[row + i][col + j] = GRASS;
							++generated_grass;
						}
		}
	}
	display();
	cout << endl;
}

void World::worldOfRabbit()
{
	srand(time(0)); // 使用当前时间作为随机数种子

	// 随机生成几只兔子
	int rabbit_count = rand() % 3 + 3; // 生成3到5只兔子
	vector<Position> rabbit_positions;

	for (int i = 0; i < rabbit_count; ++i)
	{
		int row = rand() % (N - 4) + 2; // 确保不会在边界生成
		int col = rand() % (N - 4) + 2;

		// 确保不会生成在相同位置
		while (curMap[row][col] == RABBIT)
		{
			row = rand() % (N - 4) + 2;
			col = rand() % (N - 4) + 2;
		}

		curMap[row][col] = RABBIT;
		rabbit_positions.push_back({row, col});

		// 在兔子旁边生成另一只兔子
		int direction = rand() % 4;
		switch (direction)
		{
		case 0:
			row = max(2, row - 1);
			break; // up
		case 1:
			row = min(N - 3, row + 1);
			break; // down
		case 2:
			col = max(2, col - 1);
			break; // left
		case 3:
			col = min(N - 3, col + 1);
			break; // right
		}
		curMap[row][col] = RABBIT;
		rabbit_positions.push_back({row, col});
	}

	// 剩余的位置生成草
	for (int i = 1; i < N - 1; ++i)
	{
		for (int j = 1; j < N - 1; ++j)
		{
			if (curMap[i][j] == EMPTY)
			{
				curMap[i][j] = GRASS;
			}
		}
	}
	display();
	cout << endl;
}

void World::worldOfFox()
{
	// 使用当前时间作为随机数生成器的种子
	srand(time(0));

	// 生成狐狸的位置
	int foxCount = N / 5; // 假设地图大小是 N x N，生成 N/5 只狐狸
	for (int i = 0; i < foxCount; ++i)
	{
		int row = rand() % (N - 4) + 2; // 随机生成的位置范围是 [2, N-3]
		int col = rand() % (N - 4) + 2;

		// 放置狐狸
		curMap[row][col] = FOX;

		// 放置旁边的一只狐狸
		int direction = rand() % 4;
		switch (direction)
		{
		case 0:
			curMap[row - 1][col] = FOX;
			break; // 上
		case 1:
			curMap[row + 1][col] = FOX;
			break; // 下
		case 2:
			curMap[row][col - 1] = FOX;
			break; // 左
		case 3:
			curMap[row][col + 1] = FOX;
			break; // 右
		}

		// 放置周围的兔子
		for (int dr = -1; dr <= 1; ++dr)
		{
			for (int dc = -1; dc <= 1; ++dc)
			{
				if ((dr != 0 || dc != 0) && curMap[row + dr][col + dc] != FOX)
				{
					curMap[row + dr][col + dc] = RABBIT;
				}
			}
		}
	}

	// 填充剩余位置为草
	for (int i = 1; i < N - 1; ++i)
	{
		for (int j = 1; j < N - 1; ++j)
		{
			if (curMap[i][j] == EMPTY)
			{
				curMap[i][j] = GRASS;
			}
		}
	}
	display();
	cout << endl;
}

void World::worldOfLion()
{
	// 随机生成几只狮子，每一只狮子的周围再生成一只狮子，周围生成兔子，剩下的地方生成草
	srand(time(0));

	int numLions = N / 5; // 生成 N/5 只狮子

	for (int k = 0; k < numLions; k++)
	{
		int i = rand() % (N - 4) + 2; // 确定狮子的位置
		int j = rand() % (N - 4) + 2;

		curMap[i][j] = LION; // 在指定位置生成狮子

		// 放置旁边的一只狮子
		int direction = rand() % 4;
		switch (direction)
		{
		case 0:
			curMap[i - 1][j] = LION;
			break; // 上
		case 1:
			curMap[i + 1][j] = LION;
			break; // 下
		case 2:
			curMap[i][j - 1] = LION;
			break; // 左
		case 3:
			curMap[i][j + 1] = LION;
			break; // 右
		}
		// 放置周围的兔子
		for (int dr = -1; dr <= 1; ++dr)
		{
			for (int dc = -1; dc <= 1; ++dc)
			{
				if ((dr != 0 || dc != 0) && curMap[i + dr][j + dc] != FOX)
				{
					curMap[i + dr][j + dc] = RABBIT;
				}
			}
		}
	}

	// 剩余位置生成草
	for (int i = 2; i < N - 2; i++)
	{
		for (int j = 2; j < N - 2; j++)
		{
			if (curMap[i][j] == EMPTY)
			{
				curMap[i][j] = GRASS;
			}
		}
	}
	display();
	cout << endl;
}

void World::update() // 有更新
{
	// 先计算周围生物数目统计结果
	for (int i = 1; i < N - 1; i++)
		for (int j = 1; j < N - 1; j++)
		{
			sums(Position{i, j}, cachedSums[i][j]);
		}

	// 更新各单元状态
	for (int i = 1; i < N - 1; i++)
		for (int j = 1; j < N - 1; j++)
		{
			LivingUnit *p = locate(i, j);
			curMap[i][j] = p->nextState();
		}
}

void World::display()
{
	for (int i = 0; i < N; ++i)
	{
		cout << endl;
		for (int j = 0; j < N; ++j)
		{
			switch (curMap[i][j]) // 修改了显示方式
			{
			case EMPTY:
				cout << color(FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED) << '0';
				break;
			case GRASS:
				cout << color(FOREGROUND_GREEN) << 'G';
				break;
			case RABBIT:
				cout << color(FOREGROUND_RED | FOREGROUND_GREEN) << 'R';
				break;
			case FOX:
				cout << color(FOREGROUND_RED) << 'F';
				break;
			case LION:
				cout << color(FOREGROUND_RED | FOREGROUND_BLUE) << 'L';
				break;
			}
		}
	}
	cout << endl
		 << endl;
}

LivingUnit *World::locate(int row, int colum)
{
	switch (curMap[row][colum])
	{
	case EMPTY:
		return (new EmptyUnit(this, row, colum));
		break;
	case GRASS:
		return (new GrassUnit(this, row, colum));
		break;
	case RABBIT:
		return (new RabbitUnit(this, row, colum));
		break;
	case FOX:
		return (new FoxUnit(this, row, colum));
		break;
	case LION:
		return (new LionUnit(this, row, colum));
	default:
		return nullptr; // 新增
	}
}

void World::sums(Position pos, int sum[STATES])
{
	sum[EMPTY] = sum[GRASS] = sum[RABBIT] = sum[FOX] = 0;

	for (int i = -1; i <= 1; ++i)
		for (int j = -1; j <= 1; ++j)
		{
			if (i == 0 && j == 0)
				continue;
			State state = curMap[pos.row + i][pos.colum + j];
			sum[state]++;
		}
}

void World::setUnitAt(Position pos, State state)
{
	curMap[pos.row][pos.colum] = state;
}

State World::getUnitAt(Position pos)
{
	if (pos.row >= 0 && pos.row < N && pos.colum >= 0 && pos.colum < N)
		return curMap[pos.row][pos.colum];
	else
		return EMPTY;
}
```



#### scene.h

```c++
// scene.h
#ifndef SCENE_H
#define SCENE_H

#include "basic.h"
#include "world.h"

class Scene
{
public:
	Scene(World &w);
	void update();	// 更新场景
	void display(); // 显示当前的场景
	void run();		// 场景运行

private:
	World *world;
};

#endif
```



#### scene.cpp

```c++
// scene.cpp

#include <iostream>
using namespace std;

#include "scene.h"
#include "living.h"

Scene::Scene(World &w)
{
	world = &w;
}

void Scene::update()
{
	world->update();
}

void Scene::display()
{
	world->display();
}

void Scene::run()
{
	int run_choice = -1;
	int i = 0;
	while (run_choice != 0 && i < CYCLES)
	{
		cout << color(FOREGROUND_GREEN) << "* 0 - 退出模拟 *  * 1 - 退出系统 *  * 2 - 继续模拟 *" << endl;
		cout << color(FOREGROUND_GREEN) << "请输入你的选择：";
		cin >> run_choice;
		switch (run_choice)
		{
		case 0:
			return;
		case 1:
			system("pause");
			exit(0);
		case 2:
			update();
			display();
			break;
		default:
			cout << "输入错误，请重新输入" << endl;
		}
		++i;
	}
	cout << color(FOREGROUND_GREEN) << "已达到最大步数，本轮模拟结束！！！" << endl
		 << endl;
}
```



#### living.h

```c++
// living.h
#ifndef _LIVING_H_
#define _LIVING_H_

#include "basic.h"
#include "world.h"

class World; // 前向声明 World 类

class LivingUnit // 单元格对象，分为 空的，草，兔、狐狸 等
{
public:
	virtual State getState() = 0;  // 获取生物所在位置的当前仿真时刻状态
	virtual State nextState() = 0; // 该单元下一个仿真时刻的状态
	virtual void round() = 0;	   // 周围态势，得到各类生物数目统计

protected:
	Position pos;	 // 所在的位置
	World *world;	 // 所在的世界
	int sum[STATES]; // 所在位置附近的各类生物数目统计

	// 新增保护方法
	// 通用功能给子类调用 避免在子类中重复代码
	// 同时，World类会在更新循环开始时计算每个位置的周围生物数目，并将结果缓存起来。
	// 每个单元在更新状态时会使用缓存的结果，从而避免了重复计算
	void updateSums()
	{
		for (int i = 0; i < STATES; ++i)
		{
			sum[i] = world->cachedSums[pos.row][pos.colum][i];
		}
	}
};
#endif
```



#### empty.h

```c++
// empty.h
#ifndef EMPTY_H
#define EMPTY_H
#include "living.h"

class EmptyUnit : public LivingUnit
{
public:
	EmptyUnit(World *const w, int r, int c)
	{
		pos.row = r;
		pos.colum = c;
		world = w;
	}

	State getState();
	State nextState();
	void round();
};
#endif
```



#### empty.cpp

```c++
// empty.cpp
#include "empty.h"

State EmptyUnit::getState()
{
	return EMPTY;
}

State EmptyUnit::nextState()
{
	round();

	if (sum[GRASS] > 1)
		return GRASS;
	else
		return EMPTY;
}

void EmptyUnit::round() // 更新 将代码移到living.h基类中
{
	updateSums();
}
```



#### grass.h

```c++
// grass.h
#ifndef GRASS_H
#define GRASS_H
#include "living.h"

class GrassUnit : public LivingUnit
{
public:
	GrassUnit(World *w, int r, int c)
	{
		pos.row = r;
		pos.colum = c;
		world = w;
	}

	State getState();
	State nextState();
	void round();
};
#endif
```



#### grass.cpp

```c++
// grass.cpp
#include "grass.h"
#include "empty.h"

State GrassUnit::getState()
{
	return GRASS;
}

State GrassUnit::nextState()
{
	round();
	if (sum[RABBIT] > 0)
		return EMPTY;
	else if (sum[GRASS] > 0 && sum[RABBIT] == 0)
		return GRASS;
	else
		return EMPTY;
}

void GrassUnit::round() // 更新 将代码移到living.h基类中
{
	updateSums();
}
```



#### rabbit.h

```c++
// rabbit.h
#ifndef RABBIT_H
#define RABBIT_H
#include "living.h"

class RabbitUnit : public LivingUnit
{
public:
	RabbitUnit(World *w, int r, int c, int a = 0) : age(a)
	{
		pos.row = r;
		pos.colum = c;
		world = w;
	}

	State getState();
	State nextState();
	void round();
	Position findPreyPosition();

protected:
	int age;
};
#endif
```





#### rabbit.cpp

```c++
// rabbit.cpp

#include "rabbit.h"
#include "empty.h"

State RabbitUnit::getState()
{
	return RABBIT;
}

State RabbitUnit::nextState()
{
	round();
	if (age > DRAB) // 年龄大于最大年龄，返回EMPTY
	{
		return EMPTY;
	}
	else if (sum[RABBIT] > TMRAB) // 周围兔子数大于TMRAB，返回EMPTY
	{
		return EMPTY;
	}
	else if (sum[RABBIT] > 1) // 周围有同种兔子且有食物，选择一个位置吃掉食物，并在该位置繁殖兔子
	{
		Position preyPos = findPreyPosition();
		world->setUnitAt(preyPos, RABBIT); // 在该位置繁殖兔子
		return RABBIT;					   // 返回兔子状态
	}
	else
	{
		return RABBIT; // 其他情况下保持为兔子
	}
}

void RabbitUnit::round() // 更新 将代码移到living.h基类中
{
	updateSums();
}

Position RabbitUnit::findPreyPosition()
{
	// 寻找周围有兔子的位置，并且该位置有食物（草）
	for (int i = -1; i <= 1; ++i)
	{
		for (int j = -1; j <= 1; ++j)
		{
			if (i == 0 && j == 0)
				continue;
			Position newPos = {pos.row + i, pos.colum + j};
			if (world->getUnitAt(newPos) == RABBIT && world->getUnitAt(newPos) == GRASS)
			{
				return newPos;
			}
		}
	}
	return pos;
}
```





#### fox.h

```c++
// fox.h
#ifndef FOX_H
#define FOX_H
#include "living.h"

class FoxUnit : public LivingUnit
{
public:
	FoxUnit(World *w, int r, int c, int a = 0) : age(a)
	{
		pos.row = r;
		pos.colum = c;
		world = w;
	}
	State getState();
	State nextState();
	void round();
	Position findPrey(State preyType);

protected:
	int age;
};
#endif
```



#### fox.cpp

```c++
#include "fox.h"
#include "empty.h"
#include "rabbit.h"
#include <cstdlib>
#include <ctime>

State FoxUnit::getState()
{
	return FOX;
}

State FoxUnit::nextState()
{
	round();

	if (age > DFOX) // 年龄大于最大年龄，返回EMPTY
	{
		return EMPTY;
	}
	else if (sum[FOX] > TMFOX) // 周围狐狸数大于TMRAB，返回EMPTY
	{
		return EMPTY;
	}
	else if (sum[RABBIT] > 1) // 周围有兔子且有食物，选择一个位置吃掉兔子，并在该位置繁殖狐狸
	{
		Position preyPos = findPrey(RABBIT);
		if (preyPos.row != -1 && preyPos.colum != -1)
		{
			world->setUnitAt(preyPos, FOX); // 在该位置繁殖狐狸
			world->setUnitAt(pos, EMPTY);	// 原位置变为空地
			return FOX;
		}
	}
	else if (sum[FOX] > 1) // 周围有同种狐狸且有食物，选择一个位置吃掉兔子，并在该位置繁殖狐狸
	{
		Position preyPos = findPrey(FOX);
		if (preyPos.row != -1 && preyPos.colum != -1)
		{
			world->setUnitAt(preyPos, FOX); // 在该位置繁殖狐狸
			return FOX;
		}
	}
	else
	{
		return FOX; // 其他情况下保持为狐狸
	}
}

void FoxUnit::round()
{
	world->sums(pos, sum);
}

Position FoxUnit::findPrey(State preyType)
{
	// 查找周围的食物（兔子或空地）
	std::vector<Position> preyPositions;

	for (int i = pos.row - 1; i <= pos.row + 1; ++i)
	{
		for (int j = pos.colum - 1; j <= pos.colum + 1; ++j)
		{
			if (i == pos.row && j == pos.colum)
				continue;

			if (world->getUnitAt(Position{i, j}) == preyType)
			{
				preyPositions.push_back(Position{i, j});
			}
		}
	}

	// 随机选择一个食物位置返回
	if (!preyPositions.empty())
	{
		int index = rand() % preyPositions.size();
		return preyPositions[index];
	}

	return Position{-1, -1}; // 没有找到合适的食物位置
}

```





#### lion.h

```c++
#ifndef LION_H
#define LION_H

#include "living.h"

class LionUnit : public LivingUnit
{
public:
    LionUnit(World *w, int r, int c, int a = 0) : age(a)
    {
        pos.row = r;
        pos.colum = c;
        world = w;
    }

    State getState() override;
    State nextState() override;
    void round() override;
    Position findPrey(State preyType);

protected:
    int age;
};

#endif // LION_H

```



#### lion.cpp

```c++
#include "lion.h"
#include "empty.h"
#include "rabbit.h"
#include <cstdlib>
#include <ctime>
using namespace std;

State LionUnit::getState()
{
    return LION;
}

State LionUnit::nextState()
{
    round();

    if (age > DLION) // 年龄大于最大年龄，返回EMPTY
    {
        return EMPTY;
    }
    else if (sum[LION] > TMLION) // 周围兔子数大于TMRAB，返回EMPTY
    {
        return EMPTY;
    }
    else if (sum[RABBIT] > 1) // 周围有兔子且有食物，选择一个位置吃掉兔子，并在该位置繁殖狮子
    {
        Position preyPos = findPrey(RABBIT);
        if (preyPos.row != -1 && preyPos.colum != -1)
        {
            world->setUnitAt(preyPos, LION); // 在该位置繁殖狮子
            world->setUnitAt(pos, EMPTY);    // 原位置变为空地
            return LION;
        }
    }
    else if (sum[LION] > 1) // 周围有同种狮子且有食物，选择一个位置吃掉兔子，并在该位置繁殖狮子
    {
        Position preyPos = findPrey(LION);
        if (preyPos.row != -1 && preyPos.colum != -1)
        {
            world->setUnitAt(preyPos, LION); // 在该位置繁殖狮子
            return LION;
        }
    }
    else
    {
        return LION; // 其他情况下保持为狮子
    }
}

void LionUnit::round()
{
    world->sums(pos, sum);
}

Position LionUnit::findPrey(State preyType)
{
    // 查找周围的食物（兔子或空地）
    vector<Position> preyPositions;

    for (int i = pos.row - 1; i <= pos.row + 1; ++i)
    {
        for (int j = pos.colum - 1; j <= pos.colum + 1; ++j)
        {
            if (i == pos.row && j == pos.colum)
                continue;

            if (world->getUnitAt(Position{i, j}) == preyType)
            {
                preyPositions.push_back(Position{i, j});
            }
        }
    }

    // 随机选择一个食物位置返回
    if (!preyPositions.empty())
    {
        int index = rand() % preyPositions.size();
        return preyPositions[index];
    }

    return Position{-1, -1}; // 没有找到合适的食物位置
}

```



#### main.cpp

```c++
// main.cpp
//  一个简单的生态仿真系统
#include <iostream>
#include <fstream>
using namespace std;
#include "scene.h"

int world_choice = WORLD_OF_FOX; // 默认世界选择

void show_menu()
{
	cout << "##########################################################################################" << endl;
	cout << "##                               * 欢迎进入生态仿真系统 *                               ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "##                                * 退出系统 *      请按 0                              ##" << endl;
	cout << "##                                * 进入模拟 *      请按 1                              ##" << endl;
	cout << "##                              * 修改配置数据 *    请按 2                              ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "请输入你的选择：";
}

/****************以下为开始模拟模块代码*******************/
string WorldChoiceShow(int world_choice)
{
	switch (world_choice)
	{
	case WORLD_OF_RABBIT:
		return "兔子世界";
	case WORLD_OF_FOX:
		return "狐狸世界";
	case WORLD_OF_GRASS:
		return "草世界";
	case WORLD_OF_LION:
		return "狮子世界";
	default:
		return "未知世界";
	}
}

void choose_world(int &world_choice)
{
	system("cls");
	cout << "##########################################################################################" << endl;
	cout << "##                             * 生态仿真系统选择世界页面 *                             ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
	cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
	cout << "##                                * 兔子世界 *       请按 2                             ##" << endl;
	cout << "##                                * 狐狸世界 *       请按 3                             ##" << endl;
	cout << "##                                 * 草世界 *        请按 4                             ##" << endl;
	cout << "##                                * 狮子世界 *        请按 5                            ##" << endl;
	cout << "##########################################################################################" << endl;
	cout << "当前选择的世界是：" << WorldChoiceShow(world_choice) << endl;
	cout << "请输入你的选择：";

	int world_choice_input;
	cin >> world_choice_input;
	switch (world_choice_input)
	{
	case 0:
		break;
	case 1:
		system("pause");
		exit(0);
	case 2:
		world_choice = WORLD_OF_RABBIT;
		break;
	case 3:
		world_choice = WORLD_OF_FOX;
		break;
	case 4:
		world_choice = WORLD_OF_GRASS;
		break;
	case 5:
		world_choice = WORLD_OF_LION;
		break;
	default:
		break;
	}
}

void start_simulation_menu()
{
	int sim_choice = -1;

	while (sim_choice != 0)
	{
		system("cls");
		system("COLOR 0A");
		cout << "##########################################################################################" << endl;
		cout << "##                               * 生态仿真系统模拟菜单 *                               ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
		cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
		cout << "##                                * 选择世界 *       请按 2                             ##" << endl;
		cout << "##                                * 开始模拟 *       请按 3                             ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "当前选择的世界是：" << WorldChoiceShow(world_choice) << endl;
		cout << "请输入你的选择：";
		cin >> sim_choice;
		switch (sim_choice)
		{
		case 1:
			system("pause");
			exit(0);
		case 2:
			choose_world(world_choice);
			break;
		case 3:
		{
			World world(world_choice);
			Scene scene(world);
			scene.run();
			system("pause");
			break;
		}
		default:
			break;
		}
	}
}
/***********************************************/

/****************以下为修改配置数据模块代码*******************/
void modify_data()
{
	int mod_choice = -1;
	while (mod_choice != 0)
	{
		system("cls");
		cout << "##########################################################################################" << endl;
		cout << "##                           * 生态仿真系统修改配置数据页面 *                           ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                                * 输入0 以返回上一级 *                                ##" << endl;
		cout << "##                              * 输入对应数字以修改配置 *                              ##" << endl;
		cout << "##########################################################################################" << endl;
		ShowConfig();
		cout << endl;
		cout << "请输入你要修改的配置数据的键值：";
		cin >> mod_choice;
		switch (mod_choice)
		{
		case 0:
			break;
		case DRAB_KEY:
		{
			int value;
			cout << "请输入新的兔子寿命：";
			cin >> value;
			modifyConfig("config.txt", "DRAB", value);
			break;
		}
		case DFOX_KEY:
		{
			int value;
			cout << "请输入新的狐狸寿命：";
			cin >> value;
			modifyConfig("config.txt", "DFOX", value);
			break;
		}
		case DLION_KEY:
		{
			int value;
			cout << "请输入新的狮子寿命：";
			cin >> value;
			modifyConfig("config.txt", "DLION", value);
			break;
		}
		case TMRAB_KEY:
		{
			int value;
			cout << "请输入新的太多的兔子数：";
			cin >> value;
			modifyConfig("config.txt", "TMRAB", value);
			break;
		}
		case TMFOX_KEY:
		{
			int value;
			cout << "请输入新的太多的狐狸数：";
			cin >> value;
			modifyConfig("config.txt", "TMFOX", value);
			break;
		}
		case TMLION_KEY:
		{
			int value;
			cout << "请输入新的太多的狮子数：";
			cin >> value;
			modifyConfig("config.txt", "TMLION", value);
			break;
		}
		case CYCLES_KEY:
		{
			int value;
			cout << "请输入新的仿真总步数：";
			cin >> value;
			modifyConfig("config.txt", "CYCLES", value);
			break;
		}
		default:
			break;
		}
	}
}

void modify_data_menu()
{
	int modmenu_choice = -1;
	readConfig("config.txt");
	while (modmenu_choice != 0)
	{
		system("cls");
		system("COLOR 0A");
		cout << "##########################################################################################" << endl;
		cout << "##                           * 生态仿真系统修改配置数据菜单 *                           ##" << endl;
		cout << "##########################################################################################" << endl;
		cout << "##                               * 返回上一级 *      请按 0                             ##" << endl;
		cout << "##                                * 退出系统 *       请按 1                             ##" << endl;
		cout << "##                                * 修改数据 *       请按 2                             ##" << endl;
		cout << "##########################################################################################" << endl;
		ShowConfig();
		cout << endl;
		cout << "请输入你的选择：";
		cin >> modmenu_choice;
		switch (modmenu_choice)
		{
		case 0:
			break;
		case 1:
			system("pause");
			exit(0);
		case 2:
			modify_data();
			break;
		}
	}
}
/***********************************************/

int main()
{
	system("COLOR 0A");
	int choice = -1;

	while (choice != 0)
	{
		system("cls");
		show_menu();
		cin >> choice;
		switch (choice)
		{
		case 1:
			start_simulation_menu();
			break;
		case 2:
			modify_data_menu();
			break;
		default:
			break;
		}
	}
}
```





## 5.系统测试情况

​	测试情况之前有说明，在有些地方编译器报错，已经通过参考文献中给出来的地址进行纠错。

​	最终测试结果为：各项菜单功能正常，修改配置数据功能正常。但模拟结果有一点问题，推测是规则没有编写好。该问题本人已尝试解决，但依旧解决不了。





## 6.系统的优点与不足

- 优点：
   - 用户友好性强，有多个页面菜单
   - 配置数据可外部化，用户可以修改
   - 代码可读性强，采用驼峰命名法或下划线命名法



- 缺点：
   - 只额外添加了一个物种，物种多样性不够
   - 模拟结果出现问题，该问题本人无法在有限的时间内解决，疑似规则编写出现问题





## 7.参考文献

1. "Compiler Warning (level 1) C4819." Microsoft, 2024, https://learn.microsoft.com/zh-cn/cpp/error-messages/compiler-warnings/compiler-warning-level-1-c4819?view=msvc-170&f1url=%3FappId%3DDev17IDEF1%26l%3DZH-CN%26k%3Dk(C4819)%26rd%3Dtrue. Accessed 21 June 2024.

2. "Linker Tools Error LNK2005." Microsoft, 2024, https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2005?view=msvc-170&f1url=%3FappId%3DDev17IDEF1%26l%3DZH-CN%26k%3Dk(LNK2005)%26rd%3Dtrue. Accessed 21 June 2024.

3. "Linker Tools Error LNK1120." Microsoft, 2024, https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk1120?view=msvc-170&f1url=%3FappId%3DDev17IDEF1%26l%3DZH-CN%26k%3Dk(LNK1120)%26rd%3Dtrue. Accessed 21 June 2024.

4. "Linker Tools Error LNK2019." Microsoft, 2024, https://learn.microsoft.com/zh-cn/cpp/error-messages/tool-errors/linker-tools-error-lnk2019?view=msvc-170. Accessed 21 June 2024.
